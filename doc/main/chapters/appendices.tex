\chapter{Automatic code instrumentation}\label{ann:automatic_code_instr}

Loops characterization and validation phases of this thesis motivates the development
of an automatization of the user source code instrumentation. It is for sure an
important piece of this thesis but since it is not the main development have been
decided to include it as annex.

As have been previously introduced, this work is done in the Mercurium source-to-source
compiler infrastructure by adding a new phase on the source-to-source compilation workflow
and it basically consists on inject calls to the Extrae API in order to fire events that
\begin{enumerate*}[label=\roman*)]
    \item determine the loops boundaries for the validation
    \item and additionally fire iteration-level metrics to trace for loops characterization
\end{enumerate*}
Further on next sections this process is going to be explained with more details.

\section{Instrumentation for loops characterization}\label{ann:automatic_loops_charac}

\begin{pseudocode}{MonitorLoopInit}{loop_{file}, loop_{line}}
\label{pc:mercurium_monitor_loop_init}
    instrumentLoop \GETS True\\
    \IF size(decissionStack) > 0 \THEN
    \BEGIN
      \COMMENT{Depends on if parent iteration is not instrumented}\\
      instrumentLoop \GETS top(decissionStack)\\
    \END\\
    \IF instrumentLoop \THEN
    \BEGIN
      \COMMENT{Fire loop init event}\\
        ExtraeEvent(LOOPINIT, hash(loop_{file},loop_{line}))\\
        push(iterCounterStack, 0)\\
    \END
\end{pseudocode}

\begin{pseudocode}{MonitorLoopFini}{loop_{file}, loop_{line}}
\label{pc:mercurium_monitor_loop_fini}
    instrumentLoop \GETS True\\
    \IF size(decissionStack) > 0 \THEN
    \BEGIN
      \COMMENT{Depends on if parent iteration is not instrumented}\\
      instrumentLoop \GETS top(decissionStack)\\
    \END\\
    \IF instrumentLoop \THEN
    \BEGIN
      \COMMENT{Fire loop fini event and number of static iterations}\\
        ExtraeEvent(LOOPITERS, pop(iterCounterStack)\\
        ExtraeEvent(LOOPFINI, hash(loop_{file},loop_{line}))\\
    \END
\end{pseudocode}

\begin{pseudocode}{MonitorIterInit}{chance}
\label{pc:mercurium_monitor_iter_init}
    instrumentIter \GETS True\\
    topInstrumentIter \GETS True\\
    r \in U(0,1)\\
    \IF size(decissionStack) > 0 \THEN
    \BEGIN
      \COMMENT{Depends on if parent iteration is not instrumented}\\
      topInstrumentIter \GETS top(decissionStack)\\
    \END\\
    \IF topInstrumentIter \THEN
    \BEGIN
        instrumentIter \GETS (r < chance)\\
        top(iterCounterStack)++\\
        \IF instrumentIter \THEN
        \BEGIN
            \COMMENT{Fire extrae event with HWC attached}\\
            ExtraeEventAndCounters(ITERINIT, top(iterCounterStack))\\
        \END\\
    \END\\
    push(decissionStack, instrumentIter \&  topInstrumentIter)\\
\end{pseudocode}

\begin{pseudocode}{MonitorIterFini}{chance}
\label{pc:mercurium_monitor_iter_fini}
    instrumentIter \GETS pop(decission_stack)\\
    \IF size(decissionStack) > 0 \THEN
    \BEGIN
      \COMMENT{Depends on if parent iteration is not instrumented}\\
      ExtraeEventAndCounters(ITERFINI)
    \END\\
\end{pseudocode}

\subsection{Data quality assesment}\label{ann:loops_data_quality}

In this appendix there will be demonstrated how the degradation of the sampled
data is minimum for different ``chances'' because the high regularity of HPC
applications.

\section{Instrumentation for validation}

Hola manola

